#一、关于this
this其实是函数被调用是发生的绑定，指向什么完全取决于函数在哪里被调用。
##1.为什么使用this
this提供了一种更优雅的方式来隐式地传递一个对象的引用，可以将api设计得更简洁并且易于复用
##2.误解
* 指向自身（错！）函数中this不指向自身 ，解决方法，使用函数标识符指向自身；arguments.callee来引用正在运行的函数对象（已被弃用）
* 它的作用域
#二、this全面解析
##1.调用位置
调用位置不是被声明的位置 调用栈即函数调用链
##2.绑定规则
###2.1默认绑定
this指向全局对象  ！严格模式下无法使用，this会绑定undefined
但是只要foo运行在费严格模式下就可以绑定全局变量
<pre>
function foo() {
  console.log(this.a);
}
var a =2
function () {
  'use strict'
  foo()
}
foo();//2
</pre>
###2.2 隐式绑定  
对象绑定，引用链的最后一层会影响调用位置
<pre>
obj1.obj2.foo()
</pre>
隐式丢失 会导致不绑定对象；回调函数有可能导致this丢失
<pre>
var bar = obj.foo
bar();//引用全局变量的值
</pre>
###2.3 显示绑定（apply，call，bind ）
###2.4 new绑定
 不存在所谓的构造函数，只有对于函数的构造调用。会自动执行（创建一个新的对象；这个对象会被执行原型链接；新对象绑定到函数调用的this；返回这个新对象）
##3.优先级
###