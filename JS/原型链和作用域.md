[TOC]

## 问题的由来

[函数与对象的关系](http://www.cnblogs.com/wangfupeng1988/p/3978035.html)

一直觉得这部分比较混乱，知道看到这篇，才终于明白自己的疑惑到底在哪儿？

一直说js中一切皆对象，函数也是对象，但是对象又是由函数创建而来的，函数又是对象，这种鸡生蛋，蛋生鸡的问题着实比较混乱。

函数其实也是对象，也有自己的属性，其中一个js赋予的固定属性就是prototype，**这是一个对象，他也有一个属性叫constructor，指向函数本身**

```
function Fn() { }
        Fn.prototype.name = '王福朋';
        Fn.prototype.getYear = function () {
            return 1988;
        };

        var fn = new Fn();
        console.log(fn.name);
        console.log(fn.getYear());
```

fn可以调用Fn原型对象上的属性，原因是因为，每个对象都有一个-proto-属性，指向创建这个对象的函数的原型对象。

### 所谓原型链

**访问一个对象的属性，现在对象中寻找，如果没有，则沿着-proto-这条链寻找下去，这就是原型链**

#一、原型链

##1. 显式原型链
常见的prototype
##2. 隐式原型链
用于js引擎内部对原型链的搜寻，通过显式原型链来设置。
#二、prototype和__proto__
##1. prototype
prototype是函数的一个属性（每个函数都有一个prototype属性），这个属性是一个指针，指向一个对象。显示修改对象的原型的属性。
##2. __proto__
__proto__是一个对象拥有的内置属性，是js内部使用寻找原型链的属性。ie访问不到

## 执行上下文

在执行之前的准备工作

* 变量、函数表达式声明 undefined
* this赋值
* 函数声明赋值

这三种数据的准备情况称之为执行上下文，也叫执行上下文环境。

### 作用域

## 闭包

核心：一般函数调用完成后，执行上下文环境会被销毁，但是使用闭包不会被销毁，保留函数的执行上下文环境，