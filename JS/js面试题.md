[TOC]



##位运算符（0表示错误 1表示正确）

* ~取反    
* &表示位运算符与运算     
* |运算符都为0才是0     
* ^相同为0，不同为1
* <<左移运算
* >>有符号右移
* >>>无符号右移
##1.js基本类型（5个）
undefined，null，string，boolean，number
##2，js内置对象（8个）
String，Boolean，Function，Arguments，Math，Date，RegExp，Error
##3.js基本规范
- 不在同一行声明多个变量
- 使用===/!==来比较true/false或者数值
- 不使用全局函数
- switch必须有default分支
- for in 使用var限定作用域

##4. js原型，原型链

##5.js如何实现继承
**见总结**
##6.js作用域链

js的作用域指的是变量的作用范围，内部作用域由**函数的形参，实参，局部变量，函数构成**，内部作用域和外部的作用域一层层的连接起来形成作用域链，当在函数内部要访问一个变量时，

* 现在内部作用域寻找，没有，
* 就到这个对象的原型对象中去查找
* 没有就到该作用域所在作用域中寻找，
* 直到window作用域

**每个函数声明式都默认有一个外部作用域**

全局函数无法查看局部函数的内部细节，局部函数可以查看上一级的函数细节，直至全局细节；


当需要某个变量时，当前作用域没找到，则上溯到上层作用域查找，直到全局函数，这种组织形式即作用域链

##7.this的理解
* this是js中的一个关键字，随着函数的适用场合不同，this值会发生变化
* this指的时调用函数的那个对象
* 作为函数调用this指全局对象；方法调用指的是这个对象

##11. js事件
##12. 闭包

访问其它函数作用域中的变量

* 形成闭包的必要条件：嵌套的函数可以访问外面的函数，
* 优点：有权访问另一个函数作用域中的变量的函数；避免全局变量的污染；使一个变量常驻内存；私有成员的存在
* 缺点：常驻内存，会增大内存消耗，造成内存泄漏（不用了记得解除引用）
  我的想法：我觉得，广义来讲每个函数都是闭包，嵌套的函数可以访问外面的函数的变量，但是外面的函数不能访问里面的函数的变量，因此形成闭包，由于这种现象，所以导致嵌套的函数可以访问另一个函数作用域中的变量，运用此，可以在函数中作用域中返回函数，从而使得变量常驻内存，同时兼具私有变量，其他函数不能访问，缺点是会常驻内存，容易造成内存泄漏。

##js垃圾回收原理
* js中如果一个对象不再被引用，这个对象会被回收
* 两个对象相互引用，不再被第三者引用，也会被回收
##13.js延迟加载 异步加载
defer和async的区别：defer**延迟脚本的执行**，async异步加载，但是**尽快执行**。同时存在时**async取胜**

###1.没有defer和adync

浏览器会在渲染script标签后面的元素之前，不等待后续载入的文档，读到就加载执行
###2.async 
加载和渲染后续文档元素的过程将和script的加载与执行并行进行（异步）async不考虑依赖
###3.defer 
加载异步，但是执行在所有元素解析完成之后，DOMContentLoaded事件触发之前完成
###4.创建script标签，插入到DOM中，加载完毕后callback
![](https://sfault-image.b0.upaiyun.com/28/4a/284aec5bb7f16b3ef4e7482110c5ddbb_articlex)

##ajax
是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术；

优点：

1. 通过异步模式，提升了用户体验
2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用
3. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。

模型实现：
创建XMLHttpRequest对象，创建一个异步调用的对象，创建一个新的http请求，并指定该http请求的URL，请求方法，http请求头，异步同步请求


##use strict

优点：

* 消除js语法的一些不合理的部分，不严谨之处，减少怪异行为
* 消除代码运行的不安全之处，保证代码运行安全
* 提高编译器效率，增加运行速度
* 为未来js做好铺垫


缺点：

* js merge之后，合并带了文件的中间，没有strict

##new操作符
1. 创建空对象，this引用该对象， **继承构造函数的原型对象**
2. 属性方法加入this引用的对象中
3. 新创建的对象由this引用，并且最后隐式地返回this


##9.document对象，window对象
###window
浏览器的一个窗口，是全局对象

###document
html文档，用来访问页面中的所有元素。每一个载入浏览器的html都会成为document对象，ducument对象使我们可以从脚本中对html页面中的元素进行访问；是window的一部分
##10.null undefined区别
###null 没有对象，该出不应该有值
* 作为函数的参数，表示该函数的参数是对象
* 对象原型链的终点null
###undefined 缺少值，此处应该有值，但是没定义
* 声明但没有赋值
* 调用函数，为赋值，为undefined
* 对象没有赋值属性
* 没有返回值

##16.document.write和innerHTML
document.write 重绘整个页面
innerHTML可以重绘页面的一部分

##那些操作会造成内存泄漏
内存泄漏指任何对象在您不再拥有或需要他之后依然存在

* 垃圾回收器定期扫描对象，并计算引用每个对象的其他对象的数量。如果一个对象的引用数量为0，或对该对象的唯一引用是循环的，那么该对象的内存即可回收
* setTimeout的第一个参数是字符串不是函数
* 闭包循环

##js变量声明提升
函数用var声明的变量会在函数中函数体执行前声明，但不赋值，浏览器解析时把变量的定义放在前面。

##jq的优化方法

* 基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。
* 频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。
  比如：var str=$("a").attr("href"); *for (var i = size; i < arr.length; i++) {}
* for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：
  for (var i = size, length = arr.length; i < length; i++) {}

##json js object notation
轻量级数据交换格式，数据格式简单, 易于读写, 占用带宽小 {'age':'12', 'name':'back'}

##永远不会查找原型
hasownProperty

##跨域问题

##alert(1&&2)
第一个true 返回第二个；第一个false 返回第一个
##alert（1||2）
第一个true 返回第一个，第一个false 返回第二个

##get和post区别

* get数据在URL中，post数据不会显示在URL中
* get能被缓存，post不能
* 后退按钮刷新按钮，get无害，post数据会被重新提交
* 数据长度，URL最大长度是2048个字符
* post更安全，残水不会再浏览器历史或web服务器日志中
* get只允许ASSCII字符，post也允许二进制数据
* 参数保留在浏览器历史记录中，参数不会保存在浏览器历史中
* get编码类型application/x-www-form-urlencoded；POST：application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。

##14. 模块AMD，CMD

##8.eval

##15.dom操作

##call apply的区别

##阻止a标签的默认行为

<pre>
if(event.preventDefault){
	event.preventDefault();
} else {
	event.returnValue = false;//IE
}
</pre>

##http状态码
* 1XX 信息提示请求接收，需要后续处理
* 2XX 200-206成功
* 3XX 300-305重定向
* 4XX 400-415客户端错误
* 5XX 服务气端错误

###常用
* 200 服务器成功处理了请求
* 301/302 重定向，请求的URL，返回新的位置URL
* 304 未修改  客户的缓存资源是最新的，要客户端使用缓存
* 404 未找到
* 501 服务器遇到一个错误，无法对请求提供帮助

##http协议，浏览器缓存机制304,200
###304缓存
* 304协商缓存，请求服务器，但是内容没变化，则直接使用本地缓存数据
* 304通过浏览器上的舒心按钮得到的状态码
* headers上有etag，etag是资源的唯一表时，内容变了，etag会改变
* lastModified 用于协商缓存，表时内容的修改时间
* 请求资源时将etag和last发送给服务器，服务器比对，没变化则返回304

###200 from cache
表示浏览器没有发出网络请求，直接去的本地缓存

**expires、Cache-Control**

**expires** 表示过期日期，是绝对值。适用于http1.0协议

**Cache-Control** 表示缓存的时间，是相对值，比如3600，表示3600秒后失效。适用于http1.1及以上

如有expires和Cache-Control 同时存在，Cache-Control优先级更高

**Cache-Control: no-cache：**这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是**会被缓存的**，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。

**Cache-Control: no-store：**这个才是响应不被缓存的意思。

Pragma: no-cache：跟Cache-Control: no-cache相同，Pragma: no-cache兼容http 1.0 ，Cache-Control: no-cache是http 1.1提供的。

##优雅降级渐进增强
##假设5个不同的css文件，加载进页面的最好方式是？
##对网站的文件资源进行优化
##为什么把资源存在多个域名提供网站资源会更有效
##同步异步
　　　　　同步：脚本会停留并等待服务器发送回复然后再继续。提交请求->等待服务器处理->处理完毕返回，这个期间客户端浏览器不能干任何事。

　　　　　　异步：脚本允许页面继续其进程并处理可能的回复。请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

　　　　　　　　若要在使用ajax请求后处理发送请求返回的结果，最好使用同步请求。

##如何优化网站

###文件合并（同上题“假若你有5个不同的 CSS 文件, 加载进页面的最好方式是？”）

减少调用其他页面、文件的数量。一般我们为了让页面生动活泼会大量使用background来加载背景图，而每个 background的图像都会产生1次HTTP请求，要改善这个状况，可以采用css的1个有用的background-position属 性来加载背景图，我们将需要频繁加载的多个图片合成为1个单独的图片，需要加载时可以采用：background:url(....) no-repeat x-offset y-offset;的形式加载即可将这部分图片加载的HTTP请求缩减为1个。

###文件最小化/文件压缩

即将需要传输的内容压缩后传输到客户端再解压，这样在网络上传输的 数据量就会大幅减小。通常在服务器上的Apache、Nginx可以直接开启这个设置，也可以从代码角度直接设置传输文件头，增加gzip的设置，也可以 从 负载均衡设备直接设置。不过需要留意的是，这个设置会略微增加服务器的负担。建议服务器性能不是很好的网站，要慎重考虑。

###使用 CDN 托管
CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。

###缓存的使用
Ajax调用都采用缓存调用方式，一般采用附加特征参数方式实现，注意其中的<script src=”xxx.js?{VERHASH}”，{VERHASH}就是特征参数，这个参数不变化就使用缓存文件，如果发生变化则重新下载新文件或更新信息。

css文件放置在head，js放置在文档尾部
在服务器端配置control-cache  last-modify-date
在服务器配置Entity-Tag     if-none-match
 **闻东师兄说：**
可再结合H5新特性里的预加载，图片优化方面，可对图片进行压缩，JPG的推荐jpegmin这个软件，png的推荐https://tinypng.com/，前面这两个是压缩后不会失真的，gif的推荐GIF Optimizer，但可能会有毛边。

##请解释一下什么是“语义化的 HTML”

	分离结构和表现的另一个重要方式是使用语义化的标记来构造文档内容。一个XHTML元素的存在意味着被标记内容有相应的结构化意义，例如<p>是用来标记段落<h1>标记标题<ul><li>标记列表，不能过分使用<div>

	语义化的标签往往与默认样式有所联系，像是Hx系列 表示标题，会被赋予默认的块级加粗居中样式；<strong>,<em>用来区别于其他文字，起到了强调的作用。用来明确告诉你它们的用途。

	语义化标签让大家更直观认识标签和属性的用途。语义化的网页，对搜索引擎友好，更容易被搜索引擎抓取，有利于推广。