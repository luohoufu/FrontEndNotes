两种编译方式，解释器和编译器

解释器：边翻译边执行

编译器：编译成文件再执行

问题：再循环执行相同代码时，解释器会凸显出自己的缺点，即会多次翻译，效率低；编译可以更多的去优化。



## JIT编译器

在js引擎中增加一个监视器（分析器）监视通过解释器的代码，记录代码运行了多少次，如何运行。

### 基线编译器

如果一行代码运行了几次，标记为warm，运行了很多次标记为hot；标记为warm的送去编译器进行编译，每一行生成一个stub，执行时就push出来，执行

### 优化编译器

如果一个代码段变得 “very hot”，监视器会把它发送到优化编译器中。生成一个更快速和高效的代码版本出来，并且存储之

### 一个优化的例子（类型特化）

sum 和 arr[i] 两个数并不保证都是整数。因为在 JavaScript 中类型都是动态类型，在接下来的循环当中，arr[i] 很有可能变成了string 类型。整数加法和字符串连接是完全不同的两个操作，会被编译成不同的机器码。

JIT 处理这个问题的方法是编译多基线桩。如果一个代码段是单一形态的（即总是以同一类型被调用），则只生成一个桩。如果是多形态的（即调用的过程中，类型不断变化），则会为操作所调用的每一个类型组合生成一个桩。

基线编译器中每行代码都有自己的桩，所以 JIT 在每行代码被执行的时候都会检查数据类型。在循环的每次迭代，JIT 也都会重复一次分枝选择

如果代码在执行的过程中，JIT 不是每次都重复检查的话，那么执行的还会更快一些，而这就是优化编译器所需要做的工作之一了。

**优化编译器**中，整个函数被统一编译，这样的话就可以在循环开始执行之前进行类型检查。

### 开销

为了使执行速度变快，JIT 会增加很多多余的开销，这些开销包括：

- 优化和去优化开销
- 监视器记录信息对内存的开销
- 发生去优化情况时恢复信息的记录对内存的开销
- 对基线版本和优化后版本记录的内存开销